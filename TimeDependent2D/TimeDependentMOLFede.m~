% Clear previous files
close all 
clc


%% COMPUTE STEADY STATE
% Define parameters
% Parameters shared with other routines 
global Pe Bi tha N K gamma P0 St T L D uf x1 x2 Q
Pe = 37.8; St = 8.8; P0 =0.7; Bi = 114.3; tha=0.005; D = 0.25; 
gamma = 20;  x1 = 5/7; x2 = 6.5/7; Q = 1; uf = 1; 

% Calculating the initial conditions as a solution of the steady state
% problem 
% Discretisation in t
N=800; 
% Discretisation in x
K=300;

% end of the domain
T = 2; L=1.5 ;


switch 
% Import steady state 
data = csvread('InitialConditionsK300.csv');

A0steady = data(1:K); 

th0steady=data(K+1:2*K); 
th0botsteady = data(2*K+1:3*K);
lam0steady = data(3*K+1) ; 

% Calculate steady state 
H=1;

% Plots for steady state - 1 , no plots for steady state - 0
plt = 0;
eps = 1e-4;

[Psteady, A0steady, J0steady, th0steady, xsteady] = InitialConditionsSteady(eps,H,plt);
% A0 and th0 are actually whatever size Matlab needs them to be, as it uses
% an adaptive mesh. It is our job to interpolate this accordingly. 
%close all 



% Find lam0, then resize both sides with an interpolation (only necessary
% to do this for the steady state, the conditions on the rest are much
% nicer because of our rescalings 
A0avg  = (A0steady(1:end-1)+A0steady(2:end))/2;   
th0avg = (th0steady(1:end-1) + th0steady(2:end))/2; 
xavg   = (xsteady(1:end-1) + xsteady(2:end))/2;
I =    find(A0avg>0.99999,1,'first');

lam0steady = xavg(I);

A0topsteady = interp1(xavg(1:I),A0avg(1:I),linspace(0,xavg(I),K),'pchip'); 
th0topsteady = interp1(xavg(1:I),th0avg(1:I),linspace(0,xavg(I),K),'pchip'); % pchip and cubic should be exactly the same

%A0bot = ones(size(A0top));
th0botsteady = interp1(xavg(I:end),th0avg(I:end),linspace(xavg(I),L,K),'pchip');


%% START FROM HERE WHEN YOU HAVE ALREADY CALCULATED STEADY STATE 

% Use steady state as initial condition (should show no change)
% 
% y0(1:K) = A0steady;
% y0(1+K:2*K) = A0steady.*th0steady;
% y0(2*K+1:3*K) = flip(th0botsteady);		%must flip since th0bot is stored in reverse order
% y0(3*K+1) = lam0steady; 

% Use easier initial conditions (should tend to steady state) 


A0 = (1- 1e-5 -D).*linspace(0,1,K)'+D; 
th0 = zeros(K,1); 
th0bot = zeros(K,1); 


y0(1:K) = A0;
y0(1+K:2*K) = A0.*th0;
y0(2*K+1:3*K) = flip(th0bot);		%must flip since th0bot is stored in reverse order
y0(3*K+1) = lam0steady; 


% Independent variable for ODE integration 
tout = linspace(0,T,N);

%% ODE integration 
options = odeset('RelTol',1.0e-04,'AbsTol',1.0e-04);

tic
[t,y] = ode15s(@coupledPdeFede,tout,y0); 
toc

A  = y(:,1:K); % This is A from X=0 to X=1 (this is, 0<x<lambda)

th = y(:,K+1:2*K)./A;

phi   = y(:,2*K+1:3*K);

lam = y(:,3*K+1); 

% We calculate u with the solutuon for A, th and lam
u = zeros(size(A));
for i=1:N
    u(i,:) = usolutionFede(A(i,:)',th(i,:)',lam(i),1);   
end

% We add the Dirichlet boundary conditions 
thtop = [ zeros(N,1), ...
       th         ];

Acel = [ A, ones(N,K)];														% A (cell values)
Aint = ([D*ones(N,1), A ] + [ A, ones(N,1)] )/2;  % A (interfaces)

uint  = [ u , ...
					uf.*ones(N,K+1) ];
temp = [th, phi];		% complete temperature profile (theta and phi)
				
% We rescale X and Xbar in order to plot. Note that at the top, where we
% use X, we have K+1 terms, whereas at the bottom, where we use Xbar, we
% have K terms

xint = linspace(0,1,K+1)';
xcel = linspace(xint(2)/2,1-xint(2)/2,K)';

% PLOTTING THETA
figure;
plot([xcel*lam(1);lam(1) + xcel*(L-lam(1))], temp(1,:)', '--');
hold on
numel = 10; 
for i = N/numel:(N/numel):N
	plot([xcel*lam(i);lam(i) + xcel*(L-lam(i))], temp(i,:)');
end
% set(gca,'TickLabelInterpreter','latex','fontsize',13)
hold on 
plot([xcel*lam(1);lam(1) + xcel*(L-lam(1))],[th0steady; flip(th0botsteady)]','--')
title('Temperature')

% return 
% IF you want to see the other solutions, remove the return. 
% PLOTTING A
figure; 
plot([xcel*lam(1);lam(1) + xcel*(L-lam(1))], Acel(1,:)', '--');
	hold on
for i = N/numel:(N/numel):N
	plot([xcel*lam(i);lam(i) + xcel*(L-lam(i))], Acel(i,:)');
end
plot([xcel*lam(1);lam(1) + xcel*(L-lam(1))],[A0steady; ones(K,1)]','--')
title('Area')


% PLOTTING U
figure; 
plot([xint*lam(1);lam(1) + xint(2:end)*(L-lam(1))], uint(1,:)', '--');
hold on
for i = N/numel:(N/numel):N
	plot([xint*lam(i);lam(i) + xint(2:end)*(L-lam(i))], uint(i,:)'); 
end
plot([xcel*lam(1);lam(1) + xcel*(L-lam(1))],[u0steady; ones(K,1)]','--')
title('Velocity')

% PLOTTING lambda
figure; 
plot(t, lam);
hold on
plot([t(1),t(end)], [lam(1),lam(1)]);
title('lambda')
xlabel('t')

% video version
figure('units','normalized','outerposition',[0 0 0.25 1])
for i = N/numel:(N/numel):N
	subplot(3,1,1)
	plot([xcel*lam(i);lam(i) + xcel*(L-lam(i))], temp(i,:)'), axis([0 L 0 (max(max(temp))+0.1)]);
	hold on
	plot([xcel*lam(1);lam(1) + xcel*(L-lam(1))], temp(1,:)', '--'), axis([0 L 0 (max(max(temp))+0.1)]);
	plot([lam(i),lam(i)], [0,max(max(temp))+0.1]);
	hold off
	title(strcat('T=',num2str(i*T/N)))
	ylabel('Temperature')
	subplot(3,1,2)
	plot([xcel*lam(i);lam(i) + xcel*(L-lam(i))], Acel(i,:)'), axis([0 L 0 (max(max(Acel))+0.1)]);
	hold on
	plot([xcel*lam(1);lam(1) + xcel*(L-lam(1))], Acel(1,:)', '--'), axis([0 L 0 (max(max(Acel))+0.1)]);
	hold off
	ylabel('Area')
  subplot(3,1,3)
	plot([xint*lam(i);lam(i) + xint(2:end)*(L-lam(i))], uint(i,:)'), axis([0 L 0 (max(max(uint))+0.1)]);
	hold on
	plot([xint*lam(i);lam(i) + xint(2:end)*(L-lam(i))], uint(i,:)', '--'), axis([0 L 0 (max(max(uint))+0.1)]);
	hold off
	ylabel('Velocity')
	pause(T/N)
end


